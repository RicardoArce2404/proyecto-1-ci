import java_cup.runtime.*;
import java.io.*;

parser code {:
    public void report_error(String message, Object info) {
        Symbol s = (Symbol) info;
        System.err.println("Syntax error at line " + s.left + ", column " + s.right + ": " + message);
    }
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1); // or throw new RuntimeException(message);
    }
:};

/* =========================
   TERMINALES
   ========================= */

/* palabras reservadas y nombres básicos */
terminal LET, INT, FLOAT, BOOL, CHAR, STRING, VOID, PRINCIPAL;
terminal INPUT, OUTPUT, RETURN;
terminal TRUE, FALSE;

/* estructuras de control y palabras clave */
terminal DECIDE, OF, ELSE, END, LOOP, EXIT, WHEN;
terminal FOR, STEP, TO, DOWNTO, DO;

/* literales y identificadores */
terminal ID, INT_LIT, FLOAT_LIT, CHAR_LIT, STRING_LIT;

/* símbolos especiales y delimitadores */
terminal DOLLAR;               // $
terminal LPAREN, RPAREN;       // LPAREN  RPAREN (paréntesis especiales)
terminal LBLOCK, RBLOCK;       // ¿  ? (bloque delimiters)
terminal LBRACKET, RBRACKET;   // [ ]
terminal COMMA;                // ,
terminal ARROW;                // ->

/* operadores aritméticos, incremento, etc. */
terminal PLUS, MINUS, MULT, DIV, DIVINT, MOD, POW;
terminal INC, DEC;             // ++, --
terminal ASSIGN;               // =

/* comparadores */
terminal EQ, NEQ, GT, GE, LT, LE;

/* lógicos */
terminal AND, OR, SIGMA;       // @ ~ Σ

/* NOTA: No declarar EOF (CUP lo maneja internamente) */

/* =========================
   NO TERMINALES
   ========================= */
non terminal program;
non terminal global_vars, global_var;
non terminal functions, function, params, param, main;
non terminal type_nt,type_fn, array_decl, init_nt;

non terminal expr, or_expr, and_expr, lp_rel_expr, hp_rel_expr;
non terminal logic_neg, adit_expr, mult_expr, unary_minus;
non terminal literal_numbers, power_expr, inc_dec_expr, arithm_atom;

non terminal code_block, statement, sentence, control_structure;
non terminal var_creation, var_assignment, function_call, literal_params;
non terminal inputfn, outputfn, output_value, code_block_return;

non terminal decide, decide_options, decide_option, decide_else;
non terminal loop_nt, for_nt, cs_code_block;

/* =========================
   PRECEDENCIA Y ASOCIATIVIDAD
   ========================= */

precedence left OR;
precedence left AND;
precedence left EQ, NEQ;
precedence left LT, GT, LE, GE;
precedence left PLUS, MINUS;
precedence left MULT, DIV, DIVINT, MOD;
precedence right POW;

/* =========================
   PRODUCCIONES
   ========================= */

/* Símbolo inicial */
start with program;

program ::= global_vars functions main ;

global_vars ::= global_var global_vars | ; // Intentionally left empty.

global_var ::= LET type_nt ID DOLLAR
             | LET type_nt array_decl DOLLAR
             | LET type_nt ID init_nt DOLLAR
             | LET type_nt array_decl init_nt DOLLAR ;

main ::= VOID PRINCIPAL LBLOCK code_block RBLOCK DOLLAR ;

type_nt ::= INT | FLOAT | BOOL | CHAR | STRING ;
array_decl ::= ID LBRACKET INT_LIT RBRACKET ;
init_nt ::= ASSIGN expr ;

expr ::= or_expr ;

or_expr ::= or_expr OR and_expr
          | and_expr ;

and_expr ::= and_expr AND lp_rel_expr
           | lp_rel_expr ;

lp_rel_expr ::= hp_rel_expr EQ hp_rel_expr
              | hp_rel_expr NEQ hp_rel_expr
              | hp_rel_expr ;


hp_rel_expr ::= adit_expr GT adit_expr
              | hp_rel_expr GE adit_expr
              | hp_rel_expr LT adit_expr
              | hp_rel_expr LE adit_expr
              | adit_expr
              | logic_neg
              | TRUE | FALSE | CHAR_LIT | STRING_LIT ;

logic_neg ::= SIGMA ID ;

adit_expr ::= adit_expr PLUS mult_expr
            | adit_expr MINUS mult_expr
            | mult_expr ;

mult_expr ::= mult_expr MULT unary_minus
            | mult_expr DIV unary_minus
            | mult_expr DIVINT unary_minus
            | mult_expr MOD unary_minus
            | unary_minus ;

unary_minus ::= MINUS literal_numbers
              | power_expr ;

literal_numbers ::= INT_LIT | FLOAT_LIT ;

power_expr ::= inc_dec_expr POW inc_dec_expr
             | inc_dec_expr ;

inc_dec_expr ::= ID INC
               | ID DEC
               | arithm_atom ;

arithm_atom ::= INT_LIT | FLOAT_LIT | ID
              | function_call | array_decl
              | LPAREN expr RPAREN ;

functions ::= functions function | ; // May be no functions.

function ::= type_fn ID LPAREN params RPAREN LBLOCK code_block RBLOCK DOLLAR;

type_fn ::= type_nt | VOID ;

params ::= param
         | param COMMA params
         | ; // May be no params.

param ::= type_nt ID
        | type_nt array_decl ;

code_block ::= code_block statement | ; // Empty code block.

statement ::= sentence | control_structure ;

sentence ::= var_creation | var_assignment | function_call DOLLAR |ID INC DOLLAR| ID DEC DOLLAR | inputfn | outputfn | code_block_return ;

inputfn ::= INPUT LPAREN ID RPAREN DOLLAR ;

outputfn ::= OUTPUT LPAREN output_value RPAREN DOLLAR ;

output_value ::= INT_LIT | FLOAT_LIT | STRING_LIT | ID ;

var_creation ::= LET type_nt ID DOLLAR
               | LET type_nt array_decl DOLLAR
               | LET type_nt var_assignment ;

var_assignment ::= ID init_nt DOLLAR
                 | array_decl init_nt DOLLAR ;

function_call ::= ID LPAREN literal_params RPAREN ;

literal_params ::= expr
                 | literal_params COMMA expr | ;

control_structure ::= decide | loop_nt | for_nt ;

decide ::= DECIDE OF decide_options decide_else END DECIDE ;

decide_options ::= decide_option
                 | decide_option decide_options ;

decide_option ::= LPAREN expr RPAREN ARROW LBLOCK cs_code_block RBLOCK ;

decide_else ::= ELSE ARROW LBLOCK cs_code_block RBLOCK | ; // May be no else clause.

loop_nt ::= LOOP cs_code_block EXIT WHEN expr DOLLAR END LOOP ;

for_nt ::= FOR var_assignment STEP INT_LIT TO expr DO LBLOCK cs_code_block RBLOCK
         | FOR var_assignment STEP INT_LIT DOWNTO expr DO LBLOCK cs_code_block RBLOCK ;

cs_code_block ::= cs_code_block statement
                | statement ;

code_block_return ::= RETURN expr DOLLAR ;
