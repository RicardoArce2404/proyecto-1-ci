// DISCLAIMER: Given that the grammar requires the use of "є" and "э" characters, we will use the
// character "ε" throughout the grammar to represent a "nothing" terminal. Please note the variation.


<program> ::= <global_vars> <functions>

<global_vars> ::= ε
<global_vars> ::= <global_var> <global_vars>

<global_var> ::= "let" <type> <id> $
<global_var> ::= "let" <type> <array_decl> $
<global_var> ::= "let" <type> <id> <init> $
<global_var> ::= "let" <type> <array_decl> <init> $

<main> ::= "void" "principal" ¿ <code_block> ? $

<type> ::= "int" | "float" | "bool" | "char" | "string"
<id> ::= [a-zA-Z_]([a-zA-Z_]|[0-9])*  // We use RegEx here because is too difficult without it.
<array_decl> ::= <id> [ <int> ]
<init> ::= = <expr>


// PRECEDENCE VALUES
// Primary expressions (literals, variables, <function> calls, parentheses): 10
// Increment/decrement expression: 9
// Power expression: 8
// Unary expression (unary minus, logical negation): 7
// Multiplication, division, modulo: 6
// Addition, subtraction: 5
// High precedence relational expressions (>, >=, <, <=): 4
// Low precedence relational expressions (==, !=): 3
// Logical AND: 2
// Logical OR: 1

<expr> ::= <or_expr>

<or_expr> ::= <or_expr> ~ <and_expr>
<or_expr> ::= <and_expr>  // Links to next precedence level.

<and_expr> ::= <and_expr> @ <lp_rel_expr>
<and_expr> ::= <lp_rel_expr>

<lp_rel_expr> ::= <hp_rel_expr> == <hp_rel_expr>
<lp_rel_expr> ::= <hp_rel_expr> != <hp_rel_expr>
<lp_rel_expr> ::= <hp_rel_expr>

<hp_rel_expr> ::= <adit_expr> > <adit_expr>
<hp_rel_expr> ::= <hp_rel_expr> >= <adit_expr>
<hp_rel_expr> ::= <hp_rel_expr> < <adit_expr>
<hp_rel_expr> ::= <hp_rel_expr> <= <adit_expr>
<hp_rel_expr> ::= <adit_expr>
<hp_rel_expr> ::= <logic_neg>
<hp_rel_expr> ::= <bool> | <char> | <string> // This types can't be used further down in the grammar.

<logic_neg> ::= "Σ" <bool>

<adit_expr> ::= <adit_expr> + <mult_expr>
<adit_expr> ::= <adit_expr> - <mult_expr>
<adit_expr> ::= <mult_expr>

<mult_expr> ::= <mult_expr> * <unary_minus>
<mult_expr> ::= <mult_expr> / <unary_minus>
<mult_expr> ::= <mult_expr> // <unary_minus>
<mult_expr> ::= <mult_expr> % <unary_minus>
<mult_expr> ::= <unary_minus>

<unary_minus> ::= - <literal_numbers>
<unary_minus> ::= <power_expr>

<literal_numbers> ::= <int> | <float>

<power_expr> ::= <inc_dec_expr> "^" <inc_dec_expr>
<power_expr> ::= <inc_dec_expr>

<inc_dec_expr> ::= <id> ++
<inc_dec_expr> ::= <id> --
<inc_dec_expr> ::= <arithm_atom>

<arithm_atom> ::= <int> | <float> | <id> | <function_call> | <array_decl> | є <expr> э

<int> ::= [1-9][0-9]*|0 // Negative numbers are interpreted as having a unary minus.
<float> ::= <int> "." [0-9]*[1-9] // Same with negative floats.
<bool> ::= true | false
// Accepts, between single quotes, anything that is not a backslash or any of these: \', \", \n, \t o \r: 
<char> ::= ' ([^\\]]|\['"ntr]) '
<string> ::= " (char)* "

// єэ
<functions> ::= ε
<functions> ::= <function>
<functions> ::= <function> <functions>
<function> ::= <type> <id> є <params> э ¿ <code_block> ?

<params> ::= ε
<params> ::= <param>
<params> ::= <param> "," <params>

<param> ::= <type> <id>
<param> ::= <type> <array_decl> // This is to allow arrays as parameters.

<code_block> ::= ε | <code_block> <statement>
<statement> ::= <sentence> | <control_structure>

<sentence> ::= <var_creation> | <var_asignment> | <function_call> | <inputfn> | <outputfn> | <code_block_return>

<inputfn> ::= let <input_type> <id> = input є <input_value> э $
<outputfn> ::= let <output_type> <id> = output є <output_value> э $

<input_value> ::= <int> | <float> | <id> // Solo enteros, flotantes o variables de esos tipos
<output_value> ::= <int> | <float> | <string> | <id> // Enteros, flotantes, strings o variables de esos tipos

<var_creation> ::= let <type> <id> $
<var_creation> ::= let <type> <array_decl> $
<var_creation> ::= let <type> <var_assignment>

<var_assignment> ::= <id> <init> $
<var_assignment> ::= <array_decl> <init> $

<function_call> ::= <id> є <literal_params> э

<literal_params> ::= ε
<literal_params> ::= <arithm_atom>
<literal_params> ::= <arithm_atom> , <literal_params>

<control_structure> ::= <decide> | <loop> | <for>

<decide> ::= decide of <decide_options> <decide_else> end decide $

<decide_options> ::= <decide_option>
<decide_options> ::= <decide_option> <decide_options>
<decide_option> ::=  є <expr> э -> ¿ <cs_code_block> ? 

<decide_else> ::= else -> ¿ <cs_code_block> ? | ε

<loop> ::= loop ¿ <cs_code_block> ? exit when <expr> $ end loop $

<for> ::= for <var_asignment> step <int> to <expr> do ¿ <cs_code_block> ?
<for> ::= for <var_asignment> step <int> downto <expr> do ¿ <cs_code_block> ?

<cs_code_block> ::= <cs_code_block> <statement>
<cs_code_block> ::= <statement>

<code_block_return> ::= return <expr> $

// Accepts anything but a newline until a newline appears.
oneline_comment ::= "|" ([^\\n]*(\\n))
// Accepts anything but a closing exclamation mark until one appears.
multiline_comment ::= "¡" ([^!]*) "!"
